---
description: microsegmentation
title: Microsegmentation
---

# Microsegmentation

This guide will walk Kubernetes users how to approach and implement segmenting their environment with network policies to achieve different levels of security granularity, depending on the requirement to segment at a cluster, tenant, namespace or workload level.

## Overview

Anyone who has a need to segment systems in their organization can use Calico's network policies to isolate, protect and secure Kubernetes workloads, namespaces, tenants, and hosts. This approach enhances the security and control of a network by limiting communication between different segments which has the benefit of isolating critical workloads, preventing lateral movement of threats, and meeting compliance requirements.

Traditional firewalls, some of which Calico can integrate with, are well suited to securing system perimeters, but were not designed with dynamic, containerized environments in mind. Instead, this is implemented using purpose-built network policies that allow for different levels of granularity to secure workloads, applications, namespaces, or clusters. Network policies are the tool of choice for achieving network security over traditional firewalls due to their ability to apply to Kubernetes objects based on label selectors and not IP addresses, which are often dynamic and ephemeral. 

Calico has a range of functionality that makes implementing microsegmentation in containerized environments easier and faster.
In Project Calico (Open Source), Calico network policy extends the functionality of Kubernetes network policies to:
- support global network polices (write fewer policies than span across a cluster)
- protect hosts, VMs, pods
- scale effectively
- additional actions, such as deny and log
- more flexible match rules

Commercial Calico products, such as Calico Enterprise or Calico Cloud, support the above but include a browser-based user interface that supports:
- advanced policy organization, management and visualization,
- observability features,
- automatic policy recomendations,
- policy staging, and more.

When organizations need to segment and isolate their Kubernetes environments this is typically done at three different levels: [Workload Isolation](https://www.tigera.io/blog/enabling-microsegmentation-with-calico-enterprise-2/), [Namespace Isolation](https://www.tigera.io/blog/automated-namespace-isolation-with-calico/) and [Tenant Isolation](https://www.tigera.io/blog/deep-dive/implementing-tenant-isolation-in-multi-tenant-kubernetes-clusters/).

<details>
<summary>Workload Isolation </summary>
Kubernetes network policy is defined to secure specific microservices within a tenant or namespace. Isolating individual workloads helps further reduce the attack surface and prevents lateral movement between workloads or potential performance issues.
A network policy designed for workload isolation contains more restrictive ingress and egress rules, only allowing essential communication between microservices.
For example, an application may contain frontend and backend workloads within the same namespace. If the frontend is public, and more likely to be breached, apply a microsegmentation strategy where communication between the frontend and backend is restricted. If the frontend is compromised, the likelihood of the malicious actor obtaining sensitive information from the backend is significantly reduced. Perimeter (namespace) security approach is inadequate in this situation.
</details>

<details>
<summary>Namespace Isolation </summary>
In Kubernetes, namespaces are used to separate different software applications or processes from each other by assigning them unique namespaces. This helps to prevent conflicts or interference between different applications that may be running on the same system, and owned by different users. 
Isolating and securing applications in their namespaces means developers can ensure that their software operates independently and securely without the ability to impact other namespaces in the cluster. If one application in a namespace is compromised, having secured and isolated namespaces reduces and contains the “blast radius” of that threat. 
</details>

<details>
<summary>Tenant Isolation </summary>
When cluster infrastructure is shared between tenants there may be an organizational or compliance  requirement for isolation. A tenant may contain several resources, including workloads or namespaces (secured or unsecured), and still require that perimeter security apply to the context of the tenant.
This protects each tenant from lateral movement at an infrastructure level where a malicious or opportunistic actor may seek to obtain or steal high value assets, damage or misuse applications. If one tenant is compromised, the risk to other tenants on the same infrastructure is significantly reduced.
</details>

## Concepts and Context to Understand

Before implementing a segmentation strategy in a cluster there are a few key high-level concepts that must be understood.
These are:
Security Domains
Network Security
Default Deny

If you are a Calico Enterprise or Calico Cloud user there are more features available that enable a faster and easier microsegmentatione experience.


### Security Domains

Anyone implementing microsegmentation and zero-trust should first identify all of the security domains that need to be secured. A security domain could be:

**Cluster**: The cluster can be considered a security domain. 

**Tenants**: Each tenant can be considered a separate security domain. A tenant may be comprised of a team or individuals that share the same Kubernetes infrastructure. It is a collection of applications or namespaces for which a specific security declaration is enforced.

**Namespaces**: Microservices that make up an application are typically organized into a single namespace and can be treated as separate security domains. For example, consider protecting an application from other applications in the cluster or the same tenant.

**Endpoints** A microservice comprises endpoint groups such as deployments, statefulsets, and daemonsets. Microservices, even in the same namespace, must be protected from each other to limit the blast radius if one is compromised. For example, consider a frontend and a backend microservice in the same namespace; they are in separate security domains and must be protected by security policies.

![Security domains](../static/img/use-cases/security-domains.png)

### Network Security
Successful segmentation is achieved by implementing network policies that secure security domains at the correct granularity depending on an organization's security posture or compliance requirements.

Calico’s network policies provide a richer set of policy capabilities than Kubernetes including: 
- policy ordering/priority, 
- deny rules, 
- more flexible match rules
- can be applied to multiple endpoints: pods, VMs, and host interfaces. 

There is a more detailed list of Calico network policy features available [here](https://docs.tigera.io/calico/latest/network-policy/get-started/calico-policy/calico-network-policy#features). The Kubernetes documentation outlines what network policies [do](https://kubernetes.io/docs/concepts/services-networking/network-policies/) and [do not](https://kubernetes.io/docs/concepts/services-networking/network-policies/#what-you-can-t-do-with-network-policies-at-least-not-yet) support.

Calico Open Source integration with Istio providers application security, and service mesh. This integration enables layers 5-7 security policy match criteria, end to end mTLS encryption and cryptographic identity. For more information read [this blog](https://www.tigera.io/blog/how-to-build-a-service-mesh-with-istio-and-calico/)

Calico security policies are:
- Declarative - define security intentions in yaml (or through the Create Policy UI in Calico Cloud or Calico Enterprise)
- Label-based - security policies apply to endpoints based on workload identity using label selectors. These can be combined into larger expressions using multiple operators and parentheses.
- Dynamic - Security policies are tightly coupled with workloads based on their identity, not ever-changing IP addresses

![Network policy anatomy](../static/img/use-cases/anatomy-of-policy.png)

All Calico products support label-based policies that can be applied to either a namespace or cluster-wide (global) scope.

In Kubernetes clusters, by default, without any policies in place, each microservice is allowed to communicate with each other, and with any external endpoints freely.

## Default Deny

It is recommend to create a [default deny](https://docs.tigera.io/calico/latest/network-policy/get-started/kubernetes-default-deny) policy for your Kubernetes pods. This guarantees that if no other policy is defined that explicitly allows traffic to/from a pod, then the traffic will be denied.

Note that an implicit default deny policy always occurs last; if any other policy allows the traffic, then the deny does not come into effect. The deny is executed only after all other policies are evaluated.

A global default deny policy avoids needing to define a policy every time a namespace is created. It also forces tenants of the cluster to define a network policy for every new pod. However, ensure you have the correct allow policies in place to ensure control plane traffic does not get blocked.


### Additional Functionality with Calico Enterprise and Calico Cloud

Calico Cloud and Calico Enterprise extend network policy capabilities and usability to support hierarchical tiered network policy, automatic network policy recommendations (including automatic namespace isolation) based on existing flows, and integrations with third party firewalls.
Network policies can be viewed and managed through a user interface, with the ability to stage and preview policy impact before enforcement.

Calico Open Source users may want to read this [blog](https://www.tigera.io/blog/how-to-integrate-kubernetes-rbac-and-calico-to-achieve-shift-left-security/).

This enables users to manage policies at scale leading to more efficient management and implementation of a microsegmentation strategy.

The diagram below shows an example of how policies for different security domains are grouped and organized into tiers with Calico Cloud or Enterprise.

![Tiers](../static/img/use-cases/security-policy-framework.png)

#### Global vs Namespace Policies

Calico supports global network policy (GlobalNetworkPolicy); a non-namespaced resource containing rules which are applied to any endpoints (pods, VMs, host interfaces) that match a label selector.
Network policy is a namespaced resource that only applies to workload endpoint resources (pods, containers, VMs) within that namespace. 

#### Network Policy Management
In Calico, you can use the order field (with precedence from the lowest value to highest) to control how policies are applied and evaluated. Defining policy order is important when you include both ```action: allow``` and ```action: deny``` rules that may apply to the same endpoint.
If no network policies apply to a pod, then all traffic to/from that pod is allowed. 
If one or more network policies apply to a pod containing ingress rules, then only the ingress traffic specifically allowed by those policies is allowed. 
If one or more network policies apply to a pod containing egress rules, then only the egress traffic specifically allowed by those policies is allowed.

Calico Cloud and Calico Enterprise allow hierarchical grouping of policies into tiers. Policy Tiers allow enforcement of higher-precedence policies that cannot be circumvented by other teams. Policy tiers are evaluated based on order, as are policies within each tier. Graphically, policies are evaluated from left to right, top to bottom. RBAC for each tier can be defined to restrict who can interact with each tier.

While Calico Open Source does not support policy tiers, you can use RBAC to control how different users can shape cluster security.

## Implementating microsegmentation with network policies

To implement microsegmentation it is recommended to follow a structured and repeatable approach to increase likelihood of success. These can be summarized into four broad steps:

1. Identify the security domains for which microsegmentation will be enforced, who will be responsible for them, who or which services need access to those security domains. 

2. [Define a policy](https://docs.tigera.io/calico-enterprise/latest/network-policy/beginners/) model using documented microservice communication for your application(s) or by analyzing traffic flows. When defining policies you should also consider: the scope of policies (global/namespace), who will be writing and applying the policies, and policy order (or tiers).

3. [Author and deploy security policies](https://docs.tigera.io/calico-enterprise/latest/network-policy/staged-network-policies). Once all of the correct allow policies are in place, stage a [default deny posture](https://docs.tigera.io/calico-enterprise/latest/network-policy/default-deny). You may want to identify a low-impact application or security domain first to understand and evaluate the process before prioritizing segmentation of critical security domains.

4. Re-assess any flows or new applications that may require policy remediation before enforcing a default-deny. In Project Calico, where staged policies are not supported, enforce a default deny in a staging environment to correct any policies prior to enforcing in production.

### Identification of security domains

When identifying security domains or applications to secure, you may also want to consider application criticality and compliance requirements. 
This will be unique to your organizational requirements and security posture.
Starting with a low-risk implementation in a staging environment allows you to de-risk the process before applying it to business critical security domains.

For more information on meeting compliance requirements beyond microsegmentation, review one of our [whitepapers](https://www.tigera.io/resources/?_sft_types=white-paper&_sft_Resource_Topics=compliance).

Consideration checklist:
- Compliance requirements
- Vulnerability or susceptibility to attack
- Organizational security posture (zero-trust will require more stringent segmentation)
- Criticality of applications or security domains

### Developing Policy Framework

#### Analyzing Traffic

To define a policy model, you need to know what the expected communication is within a security domain and design policies to protect those domains.
You may need to consider:
- [Will you use global or namespaced policies?](https://docs.tigera.io/calico-enterprise/latest/network-policy/policy-best-practices#use-global-network-policy-only-when-all-rules-apply-globally)
- [Do you need to protect hosts (and configure that)?](https://docs.tigera.io/calico-enterprise/latest/network-policy/hosts/)
- [Who is responsible for defining policies for different security domains?](https://docs.tigera.io/calico-enterprise/latest/network-policy/policy-best-practices#determine-who-can-write-policy)
- [What order should policies be applied in?](https://docs.tigera.io/calico-enterprise/latest/network-policy/policy-tiers/policy-tutorial-ui#policy-ordering)
- And [Tier](https://docs.tigera.io/calico-enterprise/latest/network-policy/policy-tiers/policy-tutorial-ui#tiers), for Calico Cloud or Enterprise users.

Policy models may be easier to produce if an application has documentation stating how microservices communicate over which protocols and ports. A ‘shift left’ approach also puts the onus on individuals who are more familiar with communication dependencies and can define accurate policy.

If you’re using Calico Open Source and struggling to analyze traffic flows, you may find it easier to install a text scraping tool (Fluent Bit) and pass log information to a text processing software (Elastic). This would enable Open Source users to see layer 2-3 logs and build policies from that.

Calico Cloud and Enterprise users have multiple tools available to analyze flows:
[Dynamic Service and Threat Graph](https://docs.tigera.io/calico-cloud/tutorials/calico-cloud-features/tour#service-graph) is a topographical visualization of workload communication. Through this feature, you can access flow logs that show metadata for source and destination endpoints, as well as any policies that apply to the flow and the outcome.
[Flow Visualization](https://docs.tigera.io/calico-cloud/tutorials/calico-cloud-features/tour#service-graph) shows volumetric flow data within the cluster in a 360’ view. FlowViz, in addition to Service Graph, allows users to see what flows exist within a cluster or namespace, metadata and selectors associated with endpoints and any applied policies.
[Elasticsearch and Kibana](https://docs.tigera.io/calico-cloud/tutorials/calico-cloud-features/tour#logs) are included with [Calico Cloud](https://docs.tigera.io/calico-enterprise/latest/visibility/kibana) and [Calico Enterprise](https://docs.tigera.io/calico-enterprise/latest/visibility/kibana) that enables users to explore Elasticsearch logs and gain insights into workload communication traffic volume, performance, and other key aspects of cluster operations. Log data is also summarized in custom dashboards.

#### Label Assets

As policies are identity-aware, it is likely assets within a cluster will be targetted using labels. As such, prior to authoring any policies, ensure all assets are appropriately labelled so that policy selectors can target the correct assets at the right level of segmentation.

In an example applying microsegmentation to a demo storefront, every pod within a hipstershop namespace is labelled with a compliance label in addition to an 'app' label denoting what service the pod is. This allows for multiple policies, one allowing communication between all pods with a generalized label. If necessary, further segmentation can be done where policies are applied to each type of service using selectors for different 'app' values.

When designing and applying labels, you should:

1. Integrate label design into the identification step, creating a hierarchical design that aligns with security domains.
2. Use label prefixes for classification to create a standardized approach depending on the security domain. Consider prefixing labels with the intended security domain, and designing appropriate key/value pairs that accurately represent the tenant, application, namespace, or endpoint.
3. Don't use reserved label keys, such as kubernetes, tigera or calico.
4. If using a CI/CD pipeline, ensure the right labels are being applied and set up label governance checks. This will ensure new deployments are appropriately secured from the beginning.

[More information is available on labelling best practices.](https://www.helpnetsecurity.com/2021/05/26/kubernetes-security/)

#### Creating Policies

The previous steps should set you up for success when creating policies because you will know exactly what policies need creating, with what order and tier, and what labels to use in selectors.

Before authoring any policies you may want to review the best practices for network policies in: [Calico Open Source](https://docs.tigera.io/calico/3.26/about/kubernetes-training/about-network-policy#best-practices-for-network-policies), [Calico Enterprise](https://docs.tigera.io/calico-enterprise/3.17/network-policy/policy-best-practices#policy-best-practices-for-day-one-zero-trust), [Calico Cloud](https://docs.tigera.io/calico-cloud/tutorials/training/about-network-policy#best-practices-for-network-policies).

To make policy writing easier and faster, Calico Enterprise and Calico Cloud has a number of features you may want to consider:
*Graphical Policy Editor:* [Calico Cloud](https://docs.tigera.io/calico-cloud/network-policy/policy-tiers/policy-tutorial-ui#create-a-network-policy) and [Calico Enterprise](https://docs.tigera.io/calico-enterprise/3.17/network-policy/policy-tiers/policy-tutorial-ui#create-a-network-policy) have a ‘Create Policy’ GUI to create, edit and delete policies. Policies that have been created in the GUI can be downloaded as YAML.
*DNS Policies:* [If you need to limit traffic to/from external non-Calico workloads or networks you can use external IPs or network rules.](https://docs.tigera.io/calico-enterprise/3.17/network-policy/beginners/policy-rules/external-ips-policy)
*Automatic policy recommendations:* Calico Cloud and Calico Enterprise also support [automatic policy recommendations](https://docs.tigera.io/calico-enterprise/latest/network-policy/recommendations/policy-recommendations) that automatically generate network policy to isolate namespaces. Policy recommendations can also be generated for specific namespaces or workloads for a more granular segmentation strategy. Policy Recommendations makes it easier and faster for platform operators to implement namespace isolation at scale or without experience in authoring network policies or detailed knowledge of how application workloads are communicating. Calico analyzes the flow logs that are generated from workloads, and automatically recommends and stages policies for each namespace that can be used for isolation. All recommended polices are staged by default. This allows you to preview the impact of a policy without impacting traffic flow, to assess the effectiveness of a policy, or to evaluate any unintended side-effects.
[Policy recommendations need to be enabled](https://docs.tigera.io/calico-enterprise/3.17/network-policy/recommendations/policy-recommendations#activate-and-review-policy-recommendations) per cluster and may take time to learn and analyze flows before providing recommendations.

All version of Calico support both Kubernetes network policy and Calico network policy. 

### Deploy Security Policies

In all products, policies can be applied using the CLI. Policies created in the Calico Enterprise or Calico Cloud UI can be staged or enforced through the UI.
You can check if policies have been applied:

```
kubectl get networkpolicy
kubectl describe networkpolicy <networkpolicy-name>
```
or

```
kubectl get globalnetworkpolicy
kubectl describe globalnetworkpolicy <globalnetworkpolicy-name>
```

When applying policies you will need to apply policies in such an order that it does not impact applications. 
Calico network policy supports policy ordering (when traffic is being evaluated), and Calico Enterprise and Calico Cloud additionally support Tiers.

With [Calico Open Source](https://docs.tigera.io/calico/3.26/network-policy/get-started/calico-policy/calico-network-policy#apply-network-policies-in-specific-order) you may want to define the policy order in the policy spec in addition to applying policies in the correct order.

Calico Enterprise and Calico Cloud feature hierarchical tiers that are visible on the Policies Board. Any applied policies, whether staged or enforced, will be visible on the Policies Board in the correct order.

It is important to understand how [policy endpoints match across tiers](https://docs.tigera.io/calico-enterprise/3.17/network-policy/policy-tiers/tiered-policy#policy-endpoint-matching-across-tiers).

1. Apply policies via any method. Start with granular, more generalized policies that target broader security domains.
2. Verify policies are working as intended, before applying more fine-grained, microsegmentation policies, such as at an application/workload level.
3. Ensure policies allow communication to critical/control plane services (such as kube-dns).
4. Confirm policies exist in the correct order, either via CLI, or the Policies Board (if available to you).
5. Enforce any staged policies.


### Enforce Default Deny

The default behaviour in Kubernetes is to allow all communication, unless a policy has been put in place.
A default deny policy ensures that unwanted traffic (ingress and egress) is denied by default, and policies have to be created to allow traffic. Pods without a policy (or incorrect policy) are not allowed traffic until an appropriate network policy is defined. 

Note that Global Calico Network Policies are not namespaced and affect all pods that match the policy selector. In contrast, Kubernetes Network Policies are namespaced, so you would need to create a default deny policy per namespace to achieve the same effect.
This also comes with the warning that you need to ensure the default deny does not target system pods that are critical to cluster integrity, such as this example global default deny: 

``` yaml
apiVersion: projectcalico.org/v3
kind: GlobalNetworkPolicy
metadata:
  name: deny-app-policy
spec:
  namespaceSelector: has(projectcalico.org/name) && projectcalico.org/name not in {"kube-system", "calico-system", "tigera-system"}
  types:
  - Ingress
  - Egress
  egress:
   # allow all namespaces to communicate to DNS pods
  - action: Allow
    protocol: UDP
    destination:
      selector: 'k8s-app == "kube-dns"'
      ports:
      - 53
  - action: Allow
    protocol: TCP
    destination:
      selector: 'k8s-app == "kube-dns"'
      ports:
      - 53
```

Calico Enterprise and Calico Cloud have a 'hidden' tier that contains policies to secure Calico components that have order-precedence over any user-created policies or Tiers. To ensure your cluster continues to work correctly it is not recommended to modify or try to circumvent these policies.

[Calico Open Source: Enable default deny for Kubernetes pods](https://docs.tigera.io/calico/3.26/network-policy/get-started/kubernetes-default-deny)

In Calico Cloud and Calico Enterprise the [staging policy](https://docs.tigera.io/calico-enterprise/3.17/reference/resources/stagednetworkpolicy) tool will help you find incorrect and missing policy; a global deny helps mitigate against other lateral malicious attacks.

We recommend that you create a global default deny policy after you complete writing policy for the traffic that you want to allow. Use the stage policy feature to get your allowed traffic working as expected, then lock down the cluster to block unwanted traffic. The following steps summarize best practice:

- Create a staged global default deny policy. It will show all the traffic that would be blocked if it were converted into a deny.
- Create other network policies to individually allow the traffic shown as blocked in step 1, until no connections are denied.
- Convert the staged global network policy to an enforced policy.

Steps to an enforced default-deny posture:
1. Ensure all allow policies are created first (to the best of your knowledge/ability).
2. Create a default deny policy. If globally scoped, create one policy. For namespace scoped default denies, create one policy per namespace.
3. In Calico Enterprise or Calico Cloud, stage the default deny policy either through the UI or by setting ```kind: StagedGlobalNetworkPolicy``` or ```kind: StagedNetworkPolicy```
4. In Project Calico, in lieu of staged policy functionality you should apply the default deny policy in a non-production environment first. You may optionally include a ['log' action](https://docs.tigera.io/calico/3.26/reference/resources/networkpolicy#rule) and have flows that are evaluated by the default deny recorded in the syslog.
5. Simulate your application or services and validate all policies are working as intended, and there are no issues with the application or service.
6. Once everything is validated, the default deny can be enforced or applied in a production or other environment.

### Monitor, Review, Refine

In the last step, new traffic flows are introduced to the application workloads to assess the impact and identify any defunct security policies for remediation.

There are a few ways to monitor and review whether policies are effective:
*Policies Board:* In Calico Cloud or Calico Enterprise, the policies board will be the first sign of misconfigurations, making it easy to spot policies that are denying traffic or have no endpoints assigned to them.
*Observability:* Calico Enterprise and Calico Cloud have multiple features that allow easy visual identification of potentially misconfigured policies: Service Graph, FlowViz, Policy Board, Dashboards. Commercial Calico products also include Kibana as a frontend for ElasticSearch providing richer functionality for dashboards and logs where KQL queries can be written. For an in-depth demonstration of this functionality check out [this video series](https://fast.wistia.com/embed/channel/lhjf79y3oy?wchannelid=lhjf79y3oy)
*Use curl or netcat:* While testing policies, additional pods can deployed within different security domains to use curl or netcat to test connectivity to different pods or services. These pods can be labelled to mimic other services (and have different policies apply to them) to verify connectivity.
*Logs:* Calico supports a log action within network policies, and additionally Calico Enterprise and Calico Cloud collect a wide range of logs that can be used to investigate flows and validate policies.
*Simulate your application or service:* Using and testing the deployed application and a wide range of it's functionality should show whether there are any issues after deploying policies.

If you need to create new policies or edit existing policies refer to the sections above.